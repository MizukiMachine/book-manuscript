# クリーンアーキテクチャの罠と対策：Goエンジニアが知るべき実装の真実

## 第1章: クリーンアーキテクチャと現実世界の狭間で

「クリーンアーキテクチャ」—このフレーズを聞いたとき、あなたはどんなイメージを持ちますか？

美しく整理された依存関係、明確に分離された関心事、そして長期にわたって保守しやすいコードベース。

確かに理想的です。しかし現実はどうでしょう？

多くのGoエンジニアが、クリーンアーキテクチャの実装で頭を悩ませています。「本当にこれが必要なのか？」「オーバーエンジニアリングではないか？」「納期に間に合わない」といった声をよく耳にします。

この記事では、Go言語におけるクリーンアーキテクチャの実装について、理想論だけでなく現実的な視点から考察します。とりわけ、多くのエンジニアが直面する「罠」とその「対策」に焦点を当てます。

### クリーンアーキテクチャの基本原則

まずは基本を確認しておきましょう。クリーンアーキテクチャの核となる原則は以下の通りです。

1. **依存関係ルール**: 外側から内側への依存は許されるが、内側から外側への依存は禁止
2. **関心の分離**: ビジネスロジック、ユーザーインターフェース、データベースなどを明確に分ける
3. **依存性逆転の原則**: 詳細（DBやWeb）への依存を抽象に置き換える
4. **エンティティの中心性**: ビジネスルールがシステムの中心にある

これらの原則を図で表すと以下のようになります。



```
+----------------------------------+
|             Entities             |
|                                  |
|  +----------------------------+  |
|  |         Use Cases          |  |
|  |                            |  |
|  |  +----------------------+  |  |
|  |  |      Interface       |  |  |
|  |  |      Adapters        |  |  |
|  |  |                      |  |  |
|  |  |  +-----------------+ |  |  |
|  |  |  |  Frameworks &   | |  |  |
|  |  |  |  Drivers        | |  |  |
|  |  |  +-----------------+ |  |  |
|  |  +----------------------+  |  |
|  +----------------------------+  |
+----------------------------------+
```

### Goの言語特性とクリーンアーキテクチャ

Goはクリーンアーキテクチャを実装するのに特に適した言語です。

1. **インターフェースの暗黙的実装**  
Goでは、構造体がインターフェースを「実装する」という宣言が不要です。  
単に必要なメソッドを持っているだけで、その構造体は自動的にインターフェースを満たします。これは依存性逆転の原則を実現するのに非常に便利です。  
なぜなら、ビジネスロジック層が定義したインターフェースを、データベース層などの外部レイヤーが意識せずに「たまたま満たす」形で実装できるからです。

```go
// ビジネスロジック層がポート（インターフェース）を定義
type WeatherService interface {
    GetForecast(location string) (Forecast, error)
}

// 外部レイヤーでアダプター（実装）を作成
// WeatherServiceを明示的に参照せずに済む
type openWeatherMapService struct {
    apiKey string
    client *http.Client
}

// このメソッドがあるだけで、自動的にWeatherServiceインターフェースを満たす
func (s *openWeatherMapService) GetForecast(location string) (Forecast, error) {
    // 外部APIを呼び出す実装...
}
```

2. **構造体の柔軟性**  
フィールド埋め込み（embedding）によって、コードの再利用と階層化が簡単にできます。これにより、レイヤー間のデータ変換を最小限に抑えられます。

3. **シンプルなエラー処理**  
Goのエラー値返却パターンは、各レイヤーでエラーを適切に処理・変換するのに適しています。ドメイン固有のエラーとインフラ層のエラーを明確に分離できます。

4. **並行処理モデル**  
ゴルーチンとチャネルを使った並行処理は、複雑なユースケースでも非同期処理を明確に実装できます。例えば、複数の外部天気APIから並行してデータを取得することが簡単にできます。

### クリーンアーキテクチャの利点と課題

クリーンアーキテクチャを採用する主な利点は次の通りです。

- **テスタビリティの向上**  
ビジネスロジックが外部依存（データベースやAPI）から分離されているため、モックを使った単体テストが容易になります。例えば、天気予報の計算ロジックを、実際の外部APIに接続せずにテストできます。

- **保守性の向上**    
  関心事が明確に分離されているため、変更の影響範囲が限定されます。
  例えば、データベースをMySQLからPostgreSQLに変更しても、ビジネスロジックのコードは一切変更不要です。

- **汎用性と拡張性**  
  フレームワークやデータベースなどの「詳細」を簡単に交換できます。  
  新しい天気データプロバイダーを追加する場合も、既存のコードに影響を与えずに実装できます。

一方で、以下のような課題も存在します。

- **初期開発コストの増加**  
  インターフェースや複数のレイヤーなど、抽象化のためのコードが増えるため、小規模なプロジェクトでは開発速度が落ちる可能性があります。例えば、単純なCRUD操作でも複数のファイルにコードを分散させることになります。
- **複雑さの増加**
  レイヤー間のデータ変換やインターフェースの管理が複雑になる場合があります。ドメインモデル、DTOなど複数の似たような構造体を管理する必要が生じることもあります。
- **学習曲線**
  チームの全員がアーキテクチャの原則を理解する必要があります。「なぜこのコードがここにあるべきなのか」という疑問に答えられるようになるまでに時間がかかります。

これらの課題は「罠」として立ちはだかることがありますが、適切な対策を講じることで乗り越えられます。  
この記事では、実際の天気予報APIの実装を通じて、これらの罠と対策を具体的に見ていきましょう。

### 天気予報APIの概要

これから実装する天気予報APIは、以下の機能を持ちます。

- 指定された地域の現在の天気情報を取得
- 今後5日間の天気予報を取得
- 地域名から地理座標（緯度・経度）を検索
- 過去の天気データの統計情報を取得

外部の天気データプロバイダAPIを利用しながら、クリーンアーキテクチャの原則に従って実装していきます。  
その過程で、実際のプロジェクトで直面する様々な選択と判断について考察します。

次の章では、プロジェクト構造の設計と初期設定から始めていきます。
